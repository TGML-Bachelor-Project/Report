\subsection{Model Implementation}
\label{sec:Method:ModelImplementation}
The proposed model is implemented using \hyperlink{https://pytorch.org/docs/1.9.1/}{Pytorch-1.9.1}\cite{PyTorchDocumentation} contains the learnable parameters, $\textbf{z0} \in \mathbb{R}^{N \text{x} D}$, $\textbf{v0} \in \mathbb{R}^{N \text{x} D}$ and $\beta$. Here $\beta$ is a scalar representing the common bias term, $\textbf{z0}$ and $\textbf{v0}$ are tensors where $N$ is the number of unique nodes in the TGDN, $D$ is the size of the latent Euclidean space, which is chosen to be 2 for a 2-D latent space visualization of the TDGN, and $S$ is the number of steps in the model e.g. if the model tries to learn a representation, where the velocity can change 4 times, then S = 4.
\\\\
The model also needs to have a notion of how much time a step in the $S$ dimension corresponds to. For simplicity the model assumes equal size for each step and that the start time is 0. Such that only a single step size is needed for the model:
\begin{equation}
    \Delta_{step} = \frac{t_{max}}{S}
\end{equation}
Where $t_{max}$ is the max time from the event interactions.

\subsubsection{Latent Space Position Calculation}
To compute the node intensities for the given node interactions in the training data, the model needs to find the positions of each node pair in the latent space at the time they interact. For this the model uses a $step$ function which takes as input a vector $\textbf{t} \in \mathbb{R}^{T}$ of $T$ \textit{unique} time points. Each time point $t_i$ in $\textbf{t}$ is then transformed into a vector $\boldsymbol{\Delta} \texfbf{t}_{i} \in \mathbb{R}^S$ of $S$ time delta values, where $S$ corresponds to the size of the Step dimension in the model velocity vector $v0$. The transformation from $t_i$ to $\boldsymbol{\Delta} \texfbf{t}_{i}$ is done by computing the portions of $t_i$ that falls into each step $s_j \in S$ such:
\begin{align}
    \boldsymbol{\Delta} \textbf{t}_{i-1,j-1} = 
    \begin{cases}
        \Delta_{step} \;\; &\text{for} \;\; t_i >= (\Delta_{step} \cdot j) \\
        max(0, t_i + \Delta_{step} - \Delta_{step} \cdot j) \;\; \;\; &\text{for} \;\; t_i < (\Delta_{step} \cdot j)
    \end{cases}
\end{align}
where $\boldsymbol{\Delta} \textbf{t}_{i,j}$ is the $j$'th entry of the $i$'th time delta vector and $i,i \in \{1,2,3,...,S\}$.
\\
From these delta time values and the model velocities it is possible to calculate node movements. The latent space node positions $\textbf{Z}_{t_i}$ for a given time $t_i$ can then be calculated as the latent starting positions $\textbf{Z}_{0}$ i.e. the positions at time 0, plus the cumulative sum of movements to the time point $t_i$:
\begin{align}
    \textbf{Z}_{t_i} = \textbf{Z}_{0} + \sum_{j=0}^{S-1}\textbf{V}_{j} \cdot \boldsymbol{\Delta} \textbf{t}_{i,j}
\end{align}
When this process is applied to all time points in $\textbf{t}$ we get a collection of latent position matrices $\textbf{Z}_t$ according to the number of time points i.e. $Z_t \in \mathbb{R}^{N\text{x}D\text{x}T}$, which can be used to compute the event intensity for each node pair interacting at each time point $t_i$.

\subsubsection{Learning}
\label{sec:Method:ModelImplementation:Learning}
The model training is implemented using the \hyperlink{https://pytorch.org/ignite/}{Pytorch-Ignite-0.4.7}\cite{IgniteDocumentation} framework.
 The model training uses batching to handle the large amounts of data for TDGNs with many interactions. where each batch fed to the model contains $E$ rows for $E$ node interactions and 3 columns . which are fitted using backpropagation, based on the negative of the loglikelihood presented in equation  \ref{eq:LogLikelihoodFuncExplicit} in section \ref{sec:Method:LikelihoodFunc}

\subsubsection{Adam Optimizer}
\label{sec:Method:ModelImplementation:Adam}
Training the models in this project is done using the Adam optimization algorithm, a form of stochastic gradient descent.
A gradient descent algorithm seeks to optimize learnable parameters by stepping towards the direction of the negative gradient.



\subsubsection{Position Correction}
\label{sec:Method:ModelImplementation:PositionCorrection}




