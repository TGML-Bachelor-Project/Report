\subsection{Scalability - SCVM Vectorization}
\label{sec:Method:Scalability}
A key focus of this project was to make the model scalable, in order to enable the modelling of larger, more realistic networks.
This subsection therefore describes vectorization of the model which was the essential foundation for utilizing the GPU parallelization capabilities of Pytorch CUDA\cite{CUDADocumentation} in order to dramatically improve the code execution time.

\subsubsection{Vectorized Latent Space Position Calculation}
\label{sec:Method:LatentSpacePositionCalculation}
To compute the node latent space positions in a vectorized manner, it is necessary to change the computation from working on specific nodes to working directly on the $\textbf{Z}$ and $\textbf{V}$ as tensors. Since $\textbf{V}$ is a tensor of shape $\mathbb{R}^{N \times 2 \times S}$, $N$ and $S$ being the number of nodes and steps respectively, we have to also adjust the $\Delta_j(t)$ representation from (\ref{eq:delta_t}), such that it becomes a vector representation of the portions of the time point $t$ that falls into each time step of the $S$ dimension of $\textbf{V}$.
\\
For this the model uses a $step$ function which takes as input a vector $\textbf{t} \in \mathbb{R}^{T}$ of $T$ \textit{unique} time points from the node pair interaction data. Each time point $t$ in $\textbf{t}$ is then binned into a vector $\boldsymbol{\Delta}\textbf{t} \in \mathbb{R}^{S}$ where $\boldsymbol{\Delta}\textbf{t}_j \in \mathbb{R}$ is the portion $\Delta t$ of $t$ that falls into the $j$'th step of the velocities. All these $\boldsymbol{\Delta}\textbf{t}$ vectors are held in a $\boldsymbol{\Delta}\textbf{T} \in \mathbb{R}^{T \times S}$ matrix such that:
\begin{align}
    \boldsymbol{\Delta}\textbf{T}_{i,\;j} =
    \begin{cases}
        \Delta_{step} \;\; &\text{for} \;\; t_i >= (\Delta_{step} \cdot j) \\
        \text{max}(0, t_i + \Delta_{step} - \Delta_{step} \cdot j) \;\; \;\; &\text{for} \;\; t_i < (\Delta_{step} \cdot j)
    \end{cases}
    \;\; \forall \;\; t_i \in \boldsymbol{\Delta}\textbf{t}
\end{align}
Where $j \in \{1,2,...,S\}$ is the step index.
It is now possible to calculate the node movements for every node in every step as the product of $\boldsymbol{\Delta}\textbf{T}$ broadcasted\cite{BroadcastingDocumentation} onto $\textbf{V}$. 
\begin{equation}
    \boldsymbol{\mathcal{M}} = \text{WRITE BROADCASTING FORMULA} \in \mathcal{R}^{N \times 2 \times S}
\end{equation}
The latent space node positions $\textbf{Z}_{t}$ for all nodes at all times in $\textbf{t}$ can then be calculated as the latent starting positions at time 0 $\textbf{Z}$, plus the cumulative sum of movements:
\begin{align}
    \textbf{Z}_{t_i} = \textbf{Z} + \sum_{i=1}^{S}\sum_{j=1}^{i}\boldsymbol{\mathcal{M}}_j
\end{align}
When this process is applied to all time points in $\textbf{t}$ we get a collection of latent position matrices $\textbf{Z}_t$ according to the number of time points i.e. $Z_t \in \mathbb{R}^{N\text{x}D\text{x}T}$, which can be used to compute the event intensity for each node pair interacting at each time point $t_i$.

\paragraph{Vectorized Loss Function}
DESCRIBE VECTORIZED EVENT AND NON-EVENT INTENSITIES, VECTORIZED REGULARIZATION AND COMBINE TO VECTORIZED LOSS FUNCTION.

